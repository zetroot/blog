---
layout: post
title:  "Непростое простое сравнение"
date:   2023-05-02 12:30 +0300
categories: 
---

Как можно надурить голову себе, а затем QA на ровном месте? Тестировать не тот код, который выполняется приложением!

Это очень простая мораль, из немного более сложной истории, в которой случались моя самоуверенность, черезмерная вера в тесты, недостаточное понимание того, как работают методы BCL. Пришлось с этим разобраться. Собственно рассказ об этом разбирательстве последует ниже. 

# Завязка
Положим у нас стоит задача отслеживать изменения в выписке по счету, которую можно запрашивать из банка. Интересующая нас часть выписки представляет собой коллекцию транзакций по счету, где каждая транзакция обладает следующими атрибутами:
- Идентификатор получателя транзакции (куда собственно ушли деньги, может быть не заполнен, т.е. null)
- "Номер" транзакции - это устаревшее поле, гарантируется, что поле уникально в рамках одного получателя. Может быть незаполнен (для "новых" транзакций)
- Уникальный идентификатор транзакции - глобально уникальная строка, так же может быть не заполнена.

Конечно, есть еще различные атрибуты, типа даты, суммы и т.д., но для упрощения мы их рассматривать не будем. Далее будем работать со следующей моделью транзакции:
```cs
public record Transaction(int? TargetId, string? Uid, string? Account);
```

Отслеживать наш сервис должен появление новых транзакций, и оповещать пользователя о том, что добавилась новая транзакция.
При сравнении двух выписок, надо учитывать некоторые особенности. 
- Транзакция не может поменять получателя.
- Транзакция может пропасть из выписки
- Транзакция может появиться "задним числом" или изменить свою дату (поэтому дата транзакции не учитывается как ключевое поле)
- Произошло изменение формата: часть транзакций имеет только номер, часть имеет номер и уид, часть имеет только уид. 
- При этом присвоенный уид не может пропасть
- Присвоенный номер может пропасть, но только если он был заменен на уид
- Транзакция без получателя это какой то артефакт, о ее появлении репортить не надо.

В сухом остатке, задача выглядит достаточно просто: надо вычесть из множества транзакций текущей выписки множество транзакций предыдущей выписки и зарепортить все новые элементы. При этом сравнение транзакций проводить по некоторым нехитрым правилам. И кажется что для этого есть метод `IEnumerable<T>.Except<T>()` в linq, который принимает на вход "сравниватель": объект реализующий интерфейс `IEqualityComparer<T>` отвечающий на вопрос равенства двух объектов типа `T`.

# Сравнение через IEqualityComparer
